{
  "version": 3,
  "sources": ["../../echarts/lib/label/labelGuideHelper.js"],
  "sourcesContent": ["\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\n\r\n\r\n/**\r\n * AUTO-GENERATED FILE. DO NOT MODIFY.\r\n */\r\n\r\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\r\nimport { Point, Path, Polyline } from '../util/graphic.js';\r\nimport PathProxy from 'zrender/lib/core/PathProxy.js';\r\nimport { normalizeRadian } from 'zrender/lib/contain/util.js';\r\nimport { cubicProjectPoint, quadraticProjectPoint } from 'zrender/lib/core/curve.js';\r\nimport { defaults, retrieve2 } from 'zrender/lib/core/util.js';\r\nimport { invert } from 'zrender/lib/core/matrix.js';\r\nimport * as vector from 'zrender/lib/core/vector.js';\r\nimport { DISPLAY_STATES, SPECIAL_STATES } from '../util/states.js';\r\nvar PI2 = Math.PI * 2;\r\nvar CMD = PathProxy.CMD;\r\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\r\n\r\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\r\n  var width = rect.width;\r\n  var height = rect.height;\r\n\r\n  switch (pos) {\r\n    case 'top':\r\n      outPt.set(rect.x + width / 2, rect.y - distance);\r\n      outDir.set(0, -1);\r\n      break;\r\n\r\n    case 'bottom':\r\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\r\n      outDir.set(0, 1);\r\n      break;\r\n\r\n    case 'left':\r\n      outPt.set(rect.x - distance, rect.y + height / 2);\r\n      outDir.set(-1, 0);\r\n      break;\r\n\r\n    case 'right':\r\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\r\n      outDir.set(1, 0);\r\n      break;\r\n  }\r\n}\r\n\r\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\r\n  x -= cx;\r\n  y -= cy;\r\n  var d = Math.sqrt(x * x + y * y);\r\n  x /= d;\r\n  y /= d; // Intersect point.\r\n\r\n  var ox = x * r + cx;\r\n  var oy = y * r + cy;\r\n\r\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\r\n    // Is a circle\r\n    out[0] = ox;\r\n    out[1] = oy;\r\n    return d - r;\r\n  }\r\n\r\n  if (anticlockwise) {\r\n    var tmp = startAngle;\r\n    startAngle = normalizeRadian(endAngle);\r\n    endAngle = normalizeRadian(tmp);\r\n  } else {\r\n    startAngle = normalizeRadian(startAngle);\r\n    endAngle = normalizeRadian(endAngle);\r\n  }\r\n\r\n  if (startAngle > endAngle) {\r\n    endAngle += PI2;\r\n  }\r\n\r\n  var angle = Math.atan2(y, x);\r\n\r\n  if (angle < 0) {\r\n    angle += PI2;\r\n  }\r\n\r\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\r\n    // Project point is on the arc.\r\n    out[0] = ox;\r\n    out[1] = oy;\r\n    return d - r;\r\n  }\r\n\r\n  var x1 = r * Math.cos(startAngle) + cx;\r\n  var y1 = r * Math.sin(startAngle) + cy;\r\n  var x2 = r * Math.cos(endAngle) + cx;\r\n  var y2 = r * Math.sin(endAngle) + cy;\r\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\r\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\r\n\r\n  if (d1 < d2) {\r\n    out[0] = x1;\r\n    out[1] = y1;\r\n    return Math.sqrt(d1);\r\n  } else {\r\n    out[0] = x2;\r\n    out[1] = y2;\r\n    return Math.sqrt(d2);\r\n  }\r\n}\r\n\r\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\r\n  var dx = x - x1;\r\n  var dy = y - y1;\r\n  var dx1 = x2 - x1;\r\n  var dy1 = y2 - y1;\r\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\r\n  dx1 /= lineLen;\r\n  dy1 /= lineLen; // dot product\r\n\r\n  var projectedLen = dx * dx1 + dy * dy1;\r\n  var t = projectedLen / lineLen;\r\n\r\n  if (limitToEnds) {\r\n    t = Math.min(Math.max(t, 0), 1);\r\n  }\r\n\r\n  t *= lineLen;\r\n  var ox = out[0] = x1 + t * dx1;\r\n  var oy = out[1] = y1 + t * dy1;\r\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\r\n}\r\n\r\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\r\n  if (width < 0) {\r\n    x1 = x1 + width;\r\n    width = -width;\r\n  }\r\n\r\n  if (height < 0) {\r\n    y1 = y1 + height;\r\n    height = -height;\r\n  }\r\n\r\n  var x2 = x1 + width;\r\n  var y2 = y1 + height;\r\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\r\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\r\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\r\n}\r\n\r\nvar tmpPt = [];\r\n\r\nfunction nearestPointOnRect(pt, rect, out) {\r\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\r\n  out.set(tmpPt[0], tmpPt[1]);\r\n  return dist;\r\n}\r\n/**\r\n * Calculate min distance corresponding point.\r\n * This method won't evaluate if point is in the path.\r\n */\r\n\r\n\r\nfunction nearestPointOnPath(pt, path, out) {\r\n  var xi = 0;\r\n  var yi = 0;\r\n  var x0 = 0;\r\n  var y0 = 0;\r\n  var x1;\r\n  var y1;\r\n  var minDist = Infinity;\r\n  var data = path.data;\r\n  var x = pt.x;\r\n  var y = pt.y;\r\n\r\n  for (var i = 0; i < data.length;) {\r\n    var cmd = data[i++];\r\n\r\n    if (i === 1) {\r\n      xi = data[i];\r\n      yi = data[i + 1];\r\n      x0 = xi;\r\n      y0 = yi;\r\n    }\r\n\r\n    var d = minDist;\r\n\r\n    switch (cmd) {\r\n      case CMD.M:\r\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\r\n        // 在 closePath 的时候使用\r\n        x0 = data[i++];\r\n        y0 = data[i++];\r\n        xi = x0;\r\n        yi = y0;\r\n        break;\r\n\r\n      case CMD.L:\r\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\r\n        xi = data[i++];\r\n        yi = data[i++];\r\n        break;\r\n\r\n      case CMD.C:\r\n        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\r\n        xi = data[i++];\r\n        yi = data[i++];\r\n        break;\r\n\r\n      case CMD.Q:\r\n        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\r\n        xi = data[i++];\r\n        yi = data[i++];\r\n        break;\r\n\r\n      case CMD.A:\r\n        // TODO Arc 判断的开销比较大\r\n        var cx = data[i++];\r\n        var cy = data[i++];\r\n        var rx = data[i++];\r\n        var ry = data[i++];\r\n        var theta = data[i++];\r\n        var dTheta = data[i++]; // TODO Arc 旋转\r\n\r\n        i += 1;\r\n        var anticlockwise = !!(1 - data[i++]);\r\n        x1 = Math.cos(theta) * rx + cx;\r\n        y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\r\n\r\n        if (i <= 1) {\r\n          // 第一个命令起点还未定义\r\n          x0 = x1;\r\n          y0 = y1;\r\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\r\n\r\n\r\n        var _x = (x - cx) * ry / rx + cx;\r\n\r\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\r\n        xi = Math.cos(theta + dTheta) * rx + cx;\r\n        yi = Math.sin(theta + dTheta) * ry + cy;\r\n        break;\r\n\r\n      case CMD.R:\r\n        x0 = xi = data[i++];\r\n        y0 = yi = data[i++];\r\n        var width = data[i++];\r\n        var height = data[i++];\r\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\r\n        break;\r\n\r\n      case CMD.Z:\r\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\r\n        xi = x0;\r\n        yi = y0;\r\n        break;\r\n    }\r\n\r\n    if (d < minDist) {\r\n      minDist = d;\r\n      out.set(tmpPt[0], tmpPt[1]);\r\n    }\r\n  }\r\n\r\n  return minDist;\r\n} // Temporal variable for intermediate usage.\r\n\r\n\r\nvar pt0 = new Point();\r\nvar pt1 = new Point();\r\nvar pt2 = new Point();\r\nvar dir = new Point();\r\nvar dir2 = new Point();\r\n/**\r\n * Calculate a proper guide line based on the label position and graphic element definition\r\n * @param label\r\n * @param labelRect\r\n * @param target\r\n * @param targetRect\r\n */\r\n\r\nexport function updateLabelLinePoints(target, labelLineModel) {\r\n  if (!target) {\r\n    return;\r\n  }\r\n\r\n  var labelLine = target.getTextGuideLine();\r\n  var label = target.getTextContent(); // Needs to create text guide in each charts.\r\n\r\n  if (!(label && labelLine)) {\r\n    return;\r\n  }\r\n\r\n  var labelGuideConfig = target.textGuideLineConfig || {};\r\n  var points = [[0, 0], [0, 0], [0, 0]];\r\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\r\n  var labelRect = label.getBoundingRect().clone();\r\n  labelRect.applyTransform(label.getComputedTransform());\r\n  var minDist = Infinity;\r\n  var anchorPoint = labelGuideConfig.anchor;\r\n  var targetTransform = target.getComputedTransform();\r\n  var targetInversedTransform = targetTransform && invert([], targetTransform);\r\n  var len = labelLineModel.get('length2') || 0;\r\n\r\n  if (anchorPoint) {\r\n    pt2.copy(anchorPoint);\r\n  }\r\n\r\n  for (var i = 0; i < searchSpace.length; i++) {\r\n    var candidate = searchSpace[i];\r\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\r\n    Point.scaleAndAdd(pt1, pt0, dir, len); // Transform to target coord space.\r\n\r\n    pt1.transform(targetInversedTransform); // Note: getBoundingRect will ensure the `path` being created.\r\n\r\n    var boundingRect = target.getBoundingRect();\r\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2); // TODO pt2 is in the path\r\n\r\n    if (dist < minDist) {\r\n      minDist = dist; // Transform back to global space.\r\n\r\n      pt1.transform(targetTransform);\r\n      pt2.transform(targetTransform);\r\n      pt2.toArray(points[0]);\r\n      pt1.toArray(points[1]);\r\n      pt0.toArray(points[2]);\r\n    }\r\n  }\r\n\r\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\r\n  labelLine.setShape({\r\n    points: points\r\n  });\r\n} // Temporal variable for the limitTurnAngle function\r\n\r\nvar tmpArr = [];\r\nvar tmpProjPoint = new Point();\r\n/**\r\n * Reduce the line segment attached to the label to limit the turn angle between two segments.\r\n * @param linePoints\r\n * @param minTurnAngle Radian of minimum turn angle. 0 - 180\r\n */\r\n\r\nexport function limitTurnAngle(linePoints, minTurnAngle) {\r\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\r\n    return;\r\n  }\r\n\r\n  minTurnAngle = minTurnAngle / 180 * Math.PI; // The line points can be\r\n  //      /pt1----pt2 (label)\r\n  //     /\r\n  // pt0/\r\n\r\n  pt0.fromArray(linePoints[0]);\r\n  pt1.fromArray(linePoints[1]);\r\n  pt2.fromArray(linePoints[2]);\r\n  Point.sub(dir, pt0, pt1);\r\n  Point.sub(dir2, pt2, pt1);\r\n  var len1 = dir.len();\r\n  var len2 = dir2.len();\r\n\r\n  if (len1 < 1e-3 || len2 < 1e-3) {\r\n    return;\r\n  }\r\n\r\n  dir.scale(1 / len1);\r\n  dir2.scale(1 / len2);\r\n  var angleCos = dir.dot(dir2);\r\n  var minTurnAngleCos = Math.cos(minTurnAngle);\r\n\r\n  if (minTurnAngleCos < angleCos) {\r\n    // Smaller than minTurnAngle\r\n    // Calculate project point of pt0 on pt1-pt2\r\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\r\n    tmpProjPoint.fromArray(tmpArr); // Calculate new projected length with limited minTurnAngle and get the new connect point\r\n\r\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)); // Limit the new calculated connect point between pt1 and pt2.\r\n\r\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\r\n\r\n    if (isNaN(t)) {\r\n      return;\r\n    }\r\n\r\n    if (t < 0) {\r\n      Point.copy(tmpProjPoint, pt1);\r\n    } else if (t > 1) {\r\n      Point.copy(tmpProjPoint, pt2);\r\n    }\r\n\r\n    tmpProjPoint.toArray(linePoints[1]);\r\n  }\r\n}\r\n/**\r\n * Limit the angle of line and the surface\r\n * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite\r\n */\r\n\r\nexport function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\r\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\r\n    return;\r\n  }\r\n\r\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\r\n  pt0.fromArray(linePoints[0]);\r\n  pt1.fromArray(linePoints[1]);\r\n  pt2.fromArray(linePoints[2]);\r\n  Point.sub(dir, pt1, pt0);\r\n  Point.sub(dir2, pt2, pt1);\r\n  var len1 = dir.len();\r\n  var len2 = dir2.len();\r\n\r\n  if (len1 < 1e-3 || len2 < 1e-3) {\r\n    return;\r\n  }\r\n\r\n  dir.scale(1 / len1);\r\n  dir2.scale(1 / len2);\r\n  var angleCos = dir.dot(surfaceNormal);\r\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\r\n\r\n  if (angleCos < maxSurfaceAngleCos) {\r\n    // Calculate project point of pt0 on pt1-pt2\r\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\r\n    tmpProjPoint.fromArray(tmpArr);\r\n    var HALF_PI = Math.PI / 2;\r\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\r\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\r\n\r\n    if (newAngle >= HALF_PI) {\r\n      // parallel\r\n      Point.copy(tmpProjPoint, pt2);\r\n    } else {\r\n      // Calculate new projected length with limited minTurnAngle and get the new connect point\r\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)); // Limit the new calculated connect point between pt1 and pt2.\r\n\r\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\r\n\r\n      if (isNaN(t)) {\r\n        return;\r\n      }\r\n\r\n      if (t < 0) {\r\n        Point.copy(tmpProjPoint, pt1);\r\n      } else if (t > 1) {\r\n        Point.copy(tmpProjPoint, pt2);\r\n      }\r\n    }\r\n\r\n    tmpProjPoint.toArray(linePoints[1]);\r\n  }\r\n}\r\n\r\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\r\n  var isNormal = stateName === 'normal';\r\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName); // Make sure display.\r\n\r\n  stateObj.ignore = ignore; // Set smooth\r\n\r\n  var smooth = stateModel.get('smooth');\r\n\r\n  if (smooth && smooth === true) {\r\n    smooth = 0.3;\r\n  }\r\n\r\n  stateObj.shape = stateObj.shape || {};\r\n\r\n  if (smooth > 0) {\r\n    stateObj.shape.smooth = smooth;\r\n  }\r\n\r\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\r\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\r\n}\r\n\r\nfunction buildLabelLinePath(path, shape) {\r\n  var smooth = shape.smooth;\r\n  var points = shape.points;\r\n\r\n  if (!points) {\r\n    return;\r\n  }\r\n\r\n  path.moveTo(points[0][0], points[0][1]);\r\n\r\n  if (smooth > 0 && points.length >= 3) {\r\n    var len1 = vector.dist(points[0], points[1]);\r\n    var len2 = vector.dist(points[1], points[2]);\r\n\r\n    if (!len1 || !len2) {\r\n      path.lineTo(points[1][0], points[1][1]);\r\n      path.lineTo(points[2][0], points[2][1]);\r\n      return;\r\n    }\r\n\r\n    var moveLen = Math.min(len1, len2) * smooth;\r\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\r\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\r\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\r\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\r\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\r\n  } else {\r\n    for (var i = 1; i < points.length; i++) {\r\n      path.lineTo(points[i][0], points[i][1]);\r\n    }\r\n  }\r\n}\r\n/**\r\n * Create a label line if necessary and set it's style.\r\n */\r\n\r\n\r\nexport function setLabelLineStyle(targetEl, statesModels, defaultStyle) {\r\n  var labelLine = targetEl.getTextGuideLine();\r\n  var label = targetEl.getTextContent();\r\n\r\n  if (!label) {\r\n    // Not show label line if there is no label.\r\n    if (labelLine) {\r\n      targetEl.removeTextGuideLine();\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  var normalModel = statesModels.normal;\r\n  var showNormal = normalModel.get('show');\r\n  var labelIgnoreNormal = label.ignore;\r\n\r\n  for (var i = 0; i < DISPLAY_STATES.length; i++) {\r\n    var stateName = DISPLAY_STATES[i];\r\n    var stateModel = statesModels[stateName];\r\n    var isNormal = stateName === 'normal';\r\n\r\n    if (stateModel) {\r\n      var stateShow = stateModel.get('show');\r\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\r\n\r\n      if (isLabelIgnored // Not show when label is not shown in this state.\r\n      || !retrieve2(stateShow, showNormal) // Use normal state by default if not set.\r\n      ) {\r\n          var stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];\r\n\r\n          if (stateObj) {\r\n            stateObj.ignore = true;\r\n          }\r\n\r\n          continue;\r\n        } // Create labelLine if not exists\r\n\r\n\r\n      if (!labelLine) {\r\n        labelLine = new Polyline();\r\n        targetEl.setTextGuideLine(labelLine); // Reset state of normal because it's new created.\r\n        // NOTE: NORMAL should always been the first!\r\n\r\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\r\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\r\n        } // Use same state proxy.\r\n\r\n\r\n        if (targetEl.stateProxy) {\r\n          labelLine.stateProxy = targetEl.stateProxy;\r\n        }\r\n      }\r\n\r\n      setLabelLineState(labelLine, false, stateName, stateModel);\r\n    }\r\n  }\r\n\r\n  if (labelLine) {\r\n    defaults(labelLine.style, defaultStyle); // Not fill.\r\n\r\n    labelLine.style.fill = null;\r\n    var showAbove = normalModel.get('showAbove');\r\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\r\n    labelLineConfig.showAbove = showAbove || false; // Custom the buildPath.\r\n\r\n    labelLine.buildPath = buildLabelLinePath;\r\n  }\r\n}\r\nexport function getLabelLineStatesModels(itemModel, labelLineName) {\r\n  labelLineName = labelLineName || 'labelLine';\r\n  var statesModels = {\r\n    normal: itemModel.getModel(labelLineName)\r\n  };\r\n\r\n  for (var i = 0; i < SPECIAL_STATES.length; i++) {\r\n    var stateName = SPECIAL_STATES[i];\r\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\r\n  }\r\n\r\n  return statesModels;\r\n}"],
  "mappings": "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",
  "names": ["dist"]
}
